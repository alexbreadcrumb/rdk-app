<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RDK APP v2.2.1</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React y ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  
  <!-- Babel para transpilación de JSX en el navegador -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- sql.js (SQLite para el navegador) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>

  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <!-- Google Material Symbols (Icon Font) -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Sharp:opsz,wght,FILL,GRAD@24,400,0,0" />
  
  <style>
    /* Estilo de barra de desplazamiento tipo iOS */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    /* Estilo base para los iconos */
    .material-symbols-sharp { vertical-align: middle; font-size: 20px; }
    /* Animación para Toasts */
    @keyframes slide-in { from { transform: translateX(100%); } to { transform: translateX(0); } }
    @keyframes slide-out { from { transform: translateX(0); } to { transform: translateX(100%); opacity: 0; } }
    .toast-in { animation: slide-in 0.3s ease-out forwards; }
    .toast-out { animation: slide-out 0.3s ease-in forwards; }
  </style>
</head>
<body class="bg-gray-100 dark:bg-zinc-900">
  <div id="root"></div>

  <script type="text/babel">
    // --- APP CONFIGURATION ---
    const APP_VERSION = "2.2.0";
    const SESSION_TIMEOUT_MS = 1 * 60 * 1000; // 1 minuto

    // --- SUPABASE CONFIGURATION ---
    const SUPABASE_URL = "https://rckbiacihztdsoitbnhn.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIJ1QiOjE3NTgyOTA5ODgsImV4cCI6MjA3Mzg2Njk4OH0.M8a4luWSwopQU2jwoEzkwa8J5qSaNLHPE7aTA7rusOk";
    const BUCKET_NAME = "rdkapp_bucket";

    // --- SUPABASE CLIENT INITIALIZATION ---
    let supabase;
    try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    } catch(e) {
        // This will be caught later and an error will be displayed
    }

    // --- CONSTANTS ---
    const SALT_LENGTH = 16;
    const IV_LENGTH = 12;
    const PBKDF2_ITERATIONS = 100000;
    const AUTOSAVE_DELAY = 2500; // 2.5 seconds

    // --- CRYPTO SERVICE ---
    const bufferToBase64 = (buffer) => { let binary = ''; const bytes = new Uint8Array(buffer); const len = bytes.byteLength; for (let i = 0; i < len; i++) { binary += String.fromCharCode(bytes[i]); } return window.btoa(binary); };
    const base64ToUint8Array = (base64) => { const binary_string = window.atob(base64); const len = binary_string.length; const bytes = new Uint8Array(len); for (let i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); } return bytes; };
    const deriveKey = async (password, salt) => { const passwordEncoder = new TextEncoder(); const baseKey = await window.crypto.subtle.importKey('raw', passwordEncoder.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']); return window.crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: PBKDF2_ITERATIONS, hash: 'SHA-256' }, baseKey, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']); };
    // Encrypts entire DB file (Uint8Array) -> returns Base64 string of (IV + encrypted data)
    const encryptDBFile = async (dbUint8Array, key) => { const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH)); const encryptedData = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, dbUint8Array); const combined = new Uint8Array(iv.length + encryptedData.byteLength); combined.set(iv, 0); combined.set(new Uint8Array(encryptedData), iv.length); return bufferToBase64(combined.buffer); };
    // Decrypts entire DB file (Base64 string) -> returns original Uint8Array
    const decryptDBFile = async (encryptedBase64, key) => { try { const combined = base64ToUint8Array(encryptedBase64); const iv = combined.slice(0, IV_LENGTH); const encryptedData = combined.slice(IV_LENGTH); const decryptedBuffer = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encryptedData); return new Uint8Array(decryptedBuffer); } catch (e) { throw new Error("No se pudo descifrar. La contraseña maestra podría ser incorrecta."); } };
    // Encrypts a single text field -> returns Base64 string of (IV + encrypted data)
    const encryptField = async (text, key) => { const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH)); const encodedText = new TextEncoder().encode(text); const encryptedData = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encodedText); const combined = new Uint8Array(iv.length + encryptedData.byteLength); combined.set(iv, 0); combined.set(new Uint8Array(encryptedData), iv.length); return bufferToBase64(combined.buffer); };
    // Decrypts a single text field (Base64 string) -> returns original text
    const decryptField = async (encryptedBase64, key) => { try { const combined = base64ToUint8Array(encryptedBase64); const iv = combined.slice(0, IV_LENGTH); const encryptedData = combined.slice(IV_LENGTH); const decryptedBuffer = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encryptedData); return new TextDecoder().decode(decryptedBuffer); } catch (e) { return "Error al descifrar"; }};
    
    // --- DATABASE SERVICE ---
    const createTables = (db) => { db.run(`CREATE TABLE IF NOT EXISTS credentials (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, encrypted_username TEXT NOT NULL, encrypted_password TEXT NOT NULL, comment TEXT, tag_id INTEGER, FOREIGN KEY (tag_id) REFERENCES tags(id));`); db.run(`CREATE TABLE IF NOT EXISTS metadata (key TEXT PRIMARY KEY, value TEXT);`); db.run(`CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL UNIQUE);`); };
    const getRawMetadata = (db, key) => { const res = db.exec("SELECT value FROM metadata WHERE key = ?", [key]); return (res.length > 0 && res[0].values.length > 0) ? res[0].values[0][0] : null; };
    const setRawMetadata = (db, key, value) => db.run("INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)", [key, value]);
    const getSalt = (db) => { const b64Salt = getRawMetadata(db, 'salt'); return b64Salt ? base64ToUint8Array(b64Salt) : null; };
    const setSalt = (db, saltUint8Array) => { setRawMetadata(db, 'salt', bufferToBase64(saltUint8Array.buffer)); };
    const getKeychainName = (db) => getRawMetadata(db, 'keychain_name') || 'MiLlavero';
    const setKeychainName = (db, name) => setRawMetadata(db, 'keychain_name', name);
    const initDb = async (dbBuffer) => { const SQL = window.SQL; let database; let isNew = false; if (dbBuffer && dbBuffer.byteLength > 0) { database = new SQL.Database(new Uint8Array(dbBuffer)); } else { database = new SQL.Database(); isNew = true; } if (isNew) { createTables(database); const salt = window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH)); setSalt(database, salt); setKeychainName(database, 'MiLlavero'); } const salt = getSalt(database); if (!salt) throw new Error("Archivo de base de datos inválido o corrupto: falta salt."); return { database, salt }; };
    const exportDb = (db) => db.export();
    const getCredentials = (db) => { const res = db.exec(`SELECT c.id, c.name, c.encrypted_username, c.encrypted_password, c.comment, t.name FROM credentials c LEFT JOIN tags t ON c.tag_id = t.id`); return res.length === 0 ? [] : res[0].values.map(row => ({ id: row[0], name: row[1], username: row[2], password: row[3], comment: row[4], tag: row[5] || 'Sin Etiqueta' })); };
    const addCredential = (db, cred) => db.run('INSERT INTO credentials (name, encrypted_username, encrypted_password, comment, tag_id) VALUES (?, ?, ?, ?, (SELECT id FROM tags WHERE name = ?))', [cred.name, cred.username, cred.password, cred.comment, cred.tag]);
    const updateCredential = (db, cred) => db.run('UPDATE credentials SET name = ?, encrypted_username = ?, encrypted_password = ?, comment = ?, tag_id = (SELECT id FROM tags WHERE name = ?) WHERE id = ?', [cred.name, cred.username, cred.password, cred.comment, cred.tag, cred.id]);
    const deleteCredential = (db, id) => db.run('DELETE FROM credentials WHERE id = ?', [id]);
    const getTags = (db) => { const res = db.exec('SELECT id, name FROM tags ORDER BY name'); return res.length === 0 ? [] : res[0].values.map(row => ({ id: row[0], name: row[1] })); };
    const addTag = (db, name) => db.run('INSERT INTO tags (name) VALUES (?)', [name]);
    const deleteTag = (db, id) => { const usage = db.exec('SELECT COUNT(*) FROM credentials WHERE tag_id = ?', [id]); if (usage[0].values[0][0] > 0) throw new Error("No se puede eliminar la etiqueta porque está en uso."); db.run('DELETE FROM tags WHERE id = ?', [id]); };
    
    // --- UI COMPONENTS ---
    const Icon = ({ name, className }) => <span className={`material-symbols-sharp ${className || ''}`}>{name}</span>;
    const Spinner = ({ className }) => <div className={`animate-spin rounded-full h-5 w-5 border-b-2 ${className || 'border-white'}`}></div>;
    
    // --- Notification System ---
    const NotificationContext = React.createContext();
    const useNotifier = () => React.useContext(NotificationContext);
    
    const Toast = ({ message, type, onClose }) => { const [isExiting, setIsExiting] = React.useState(false); const baseStyle = "w-full max-w-sm p-4 text-white rounded-lg shadow-lg flex items-center"; const typeStyles = { success: "bg-green-500", error: "bg-red-500", info: "bg-blue-500" }; const icons = { success: "check_circle", error: "error", info: "info" }; React.useEffect(() => { const timer = setTimeout(() => { setIsExiting(true); setTimeout(onClose, 300); }, 4000); return () => clearTimeout(timer); }, [onClose]); return (<div className={`${baseStyle} ${typeStyles[type]} ${isExiting ? 'toast-out' : 'toast-in'}`}><Icon name={icons[type]} className="mr-3 text-2xl"/><p className="flex-grow">{message}</p><button onClick={() => { setIsExiting(true); setTimeout(onClose, 300); }} className="ml-4 p-1 rounded-full hover:bg-black/20"><Icon name="close" className="text-xl"/></button></div>); };
    const NotifierProvider = ({ children }) => { const [toasts, setToasts] = React.useState([]); const toastId = React.useRef(0); const addToast = React.useCallback((message, type = 'info') => { setToasts(currentToasts => [...currentToasts, { id: toastId.current++, message, type }]); }, []); const removeToast = React.useCallback((id) => { setToasts(currentToasts => currentToasts.filter(toast => toast.id !== id)); }, []); return (<NotificationContext.Provider value={addToast}>{children}<div className="fixed top-20 right-4 z-[100] space-y-2">{toasts.map(toast => <Toast key={toast.id} {...toast} onClose={() => removeToast(toast.id)} />)}</div></NotificationContext.Provider>); };
    
    // --- Global Layout Components ---
    const GlobalHeader = () => (<header className="fixed top-0 left-0 right-0 z-30 flex items-center justify-center p-4 h-16 border-b border-gray-200 dark:border-zinc-700 bg-white/80 dark:bg-zinc-900/80 backdrop-blur-sm"><h1 className="text-xl font-bold text-gray-900 dark:text-white truncate">RDK APP v{APP_VERSION}</h1></header>);
    const GlobalFooter = () => (<footer className="fixed bottom-0 left-0 right-0 bg-gray-100 dark:bg-zinc-800 border-t border-gray-200 dark:border-zinc-700 p-2 text-center text-sm text-gray-500 dark:text-gray-400 z-30 h-10 flex items-center justify-center">Solution by Ale Fernández 2025 - PY - v{APP_VERSION}</footer>);

    // --- Other UI Components ---
    const SettingsModal = ({ isOpen, onClose, keychainName, onSaveKeychainName, tags, onAddTag, onDeleteTag, addToast }) => { const { useState, useEffect } = React; const [name, setName] = useState(keychainName); const [newTagName, setNewTagName] = useState(''); useEffect(() => { setName(keychainName); }, [isOpen, keychainName]); if (!isOpen) return null; const handleSaveName = () => { if (name.trim()) { onSaveKeychainName(name.trim()); } }; const handleAddTag = (e) => { e.preventDefault(); if (newTagName.trim() && !tags.some(t => t.name.toLowerCase() === newTagName.trim().toLowerCase())) { onAddTag(newTagName.trim()); setNewTagName(''); } else { addToast("La etiqueta no puede estar vacía o ya existe.", "error"); } }; return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" onClick={onClose}><div className="bg-white dark:bg-zinc-800 rounded-lg shadow-xl w-full max-w-lg m-4" onClick={(e) => e.stopPropagation()}><div className="p-6"><h2 className="text-xl font-bold text-gray-900 dark:text-white">Configuración</h2><div className="mt-6 space-y-6"><div><label htmlFor="keychainName" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Nombre del Llavero</label><div className="flex mt-1"><input type="text" name="keychainName" id="keychainName" value={name} onChange={(e) => setName(e.target.value)} className="flex-grow block w-full rounded-l-md border-gray-300 dark:border-zinc-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /><button onClick={handleSaveName} className="px-4 py-2 border border-blue-600 bg-blue-600 text-white rounded-r-md hover:bg-blue-700 text-sm font-medium">Guardar Nombre</button></div></div><div><h3 className="text-lg font-medium text-gray-900 dark:text-white">Gestionar Etiquetas</h3><form onSubmit={handleAddTag} className="flex mt-2"><input type="text" value={newTagName} onChange={(e) => setNewTagName(e.target.value)} placeholder="Nueva etiqueta" className="flex-grow block w-full rounded-l-md border-gray-300 dark:border-zinc-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /><button type="submit" className="px-4 py-2 border border-blue-600 bg-blue-600 text-white rounded-r-md hover:bg-blue-700 text-sm font-medium">Agregar</button></form><div className="mt-3 max-h-40 overflow-y-auto space-y-2 pr-2">{tags.map(tag => (<div key={tag.id} className="flex justify-between items-center bg-gray-100 dark:bg-zinc-700 p-2 rounded-md"><span className="text-sm text-gray-800 dark:text-gray-200">{tag.name}</span><button onClick={() => onDeleteTag(tag.id)} className="text-red-500 hover:text-red-700 dark:hover:text-red-400"><Icon name="delete" className="text-base" /></button></div>))}</div></div></div></div><div className="bg-gray-50 dark:bg-zinc-900/50 px-6 py-4 flex justify-end"><button type="button" onClick={onClose} className="py-2 px-4 border border-gray-300 dark:border-zinc-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-zinc-700 hover:bg-gray-50 dark:hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Cerrar</button></div></div></div>); };
    const CredentialModal = ({ isOpen, onClose, onSave, credential, tags, addToast, masterKey }) => {
        const { useState, useEffect } = React;
        const [formData, setFormData] = useState({ name: '', username: '', password: '', comment: '', tag: '' });
        
        useEffect(() => {
            const decryptAndSet = async () => {
                if (credential && masterKey) {
                    const [decUsername, decPassword] = await Promise.all([
                        decryptField(credential.username, masterKey),
                        decryptField(credential.password, masterKey)
                    ]);
                    setFormData({ ...credential, username: decUsername, password: decPassword, tag: credential.tag || (tags.length > 0 ? tags[0].name : '') });
                } else {
                    setFormData({ name: '', username: '', password: '', comment: '', tag: tags.length > 0 ? tags[0].name : '' });
                }
            };
            if(isOpen) decryptAndSet();
        }, [credential, tags, isOpen, masterKey]);

        const handleChange = (e) => { const { name, value } = e.target; setFormData(prev => ({ ...prev, [name]: value })); };
        
        const handleSubmit = async (e) => {
            e.preventDefault();
            if (!formData.name || !formData.username || !formData.password) { addToast("Nombre, Usuario y Contraseña son requeridos.", "error"); return; }
            if (tags.length > 0 && !formData.tag) { addToast("Debe seleccionar una etiqueta.", "error"); return; }
            
            const [encUsername, encPassword] = await Promise.all([
                encryptField(formData.username, masterKey),
                encryptField(formData.password, masterKey)
            ]);
            
            onSave({ ...formData, username: encUsername, password: encPassword });
        };
        if (!isOpen) return null;
        return (<div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" onClick={onClose}><div className="bg-white dark:bg-zinc-800 rounded-lg shadow-xl w-full max-w-lg m-4" onClick={(e) => e.stopPropagation()}><form onSubmit={handleSubmit}><div className="p-6"><h2 className="text-xl font-bold text-gray-900 dark:text-white">{credential ? 'Editar Credencial' : 'Agregar Nueva Credencial'}</h2><div className="mt-6 space-y-4"><div><label htmlFor="name" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Nombre</label><input type="text" name="name" id="name" value={formData.name} onChange={handleChange} required className="mt-1 block w-full rounded-md border-gray-300 dark:border-zinc-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /></div><div><label htmlFor="username" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Usuario / Email</label><input type="text" name="username" id="username" value={formData.username} onChange={handleChange} required className="mt-1 block w-full rounded-md border-gray-300 dark:border-zinc-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /></div><div><label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Contraseña</label><input type="text" name="password" id="password" value={formData.password} onChange={handleChange} required className="mt-1 block w-full rounded-md border-gray-300 dark:border-zinc-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /></div><div><label htmlFor="comment" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Comentario</label><textarea name="comment" id="comment" value={formData.comment} onChange={handleChange} rows={3} className="mt-1 block w-full rounded-md border-gray-300 dark:border-zinc-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white"></textarea></div><div><label htmlFor="tag" className="block text-sm font-medium text-gray-700 dark:text-gray-300">Etiqueta</label><select name="tag" id="tag" value={formData.tag} onChange={handleChange} className="mt-1 block w-full rounded-md border-gray-300 dark:border-zinc-600 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" disabled={tags.length === 0}>{tags.length === 0 ? <option>Cree una etiqueta primero</option> : tags.map(tag => <option key={tag.id} value={tag.name}>{tag.name}</option>)}</select></div></div></div><div className="bg-gray-50 dark:bg-zinc-900/50 px-6 py-4 flex justify-end space-x-3"><button type="button" onClick={onClose} className="py-2 px-4 border border-gray-300 dark:border-zinc-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-zinc-700 hover:bg-gray-50 dark:hover:bg-zinc-600">Cancelar</button><button type="submit" className="py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700">Guardar</button></div></form></div></div>); };
    const CredentialItem = ({ credential, onEdit, onDelete, masterKey }) => { const { useState } = React; const [isExpanded, setIsExpanded] = useState(false); const [isPasswordVisible, setIsPasswordVisible] = useState(false); const [decryptedPassword, setDecryptedPassword] = useState(null); const [isUsernameVisible, setIsUsernameVisible] = useState(false); const [decryptedUsername, setDecryptedUsername] = useState(null); const addToast = useNotifier(); const handleToggleUsername = async () => { if (isUsernameVisible) { setIsUsernameVisible(false); setDecryptedUsername(null); } else { const decUsername = await decryptField(credential.username, masterKey); setDecryptedUsername(decUsername); setIsUsernameVisible(true); } }; const handleTogglePassword = async () => { if (isPasswordVisible) { setIsPasswordVisible(false); setDecryptedPassword(null); } else { const decPassword = await decryptField(credential.password, masterKey); setDecryptedPassword(decPassword); setIsPasswordVisible(true); } }; const handleCopy = async (encryptedValue, field) => { const decryptedValue = await decryptField(encryptedValue, masterKey); navigator.clipboard.writeText(decryptedValue); addToast(`${field} copiado al portapapeles.`, 'success'); }; const getTagColor = (tagName) => { if(!tagName) tagName = 'Sin Etiqueta'; let hash = 0; for (let i = 0; i < tagName.length; i++) { hash = tagName.charCodeAt(i) + ((hash << 5) - hash); } const color = (hash & 0x00FFFFFF).toString(16).toUpperCase(); const hexColor = "00000".substring(0, 6 - color.length) + color; const r = parseInt(hexColor.substring(0,2), 16); const g = parseInt(hexColor.substring(2,4), 16); const b = parseInt(hexColor.substring(4,6), 16); const brightness = (r * 299 + g * 587 + b * 114) / 1000; const textColor = brightness > 125 ? 'text-black' : 'text-white'; return { backgroundColor: `#${hexColor}`, colorClass: textColor }; }; const tagStyle = getTagColor(credential.tag); return (<div className="bg-gray-50 dark:bg-zinc-700/50 rounded-lg shadow-sm transition-shadow hover:shadow-md"><button onClick={() => setIsExpanded(!isExpanded)} className="w-full flex items-center justify-between p-4 text-left"><div className="flex items-center min-w-0 mr-4"><div className={`flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center mr-4 text-lg font-bold text-white bg-gradient-to-br from-blue-500 to-indigo-600`}>{credential.name.charAt(0).toUpperCase()}</div><div className="truncate"><p className="font-semibold text-gray-900 dark:text-white truncate">{credential.name}</p></div></div><div className='flex items-center flex-shrink-0'><span className={`text-xs font-medium mr-2 sm:mr-4 px-2.5 py-0.5 rounded-full truncate ${tagStyle.colorClass}`} style={{ backgroundColor: tagStyle.backgroundColor }}>{credential.tag}</span><Icon name="expand_more" className={`text-gray-400 transition-transform ${isExpanded ? 'rotate-180' : ''}`} /></div></button>{isExpanded && (<div className="px-4 pb-4 border-t border-gray-200 dark:border-zinc-600"><div className="mt-4 space-y-4"><div><label className="text-xs font-medium text-gray-500 dark:text-gray-400">Usuario / Email</label><div className="flex items-center mt-1"><input type={isUsernameVisible ? 'text' : 'password'} readOnly value={isUsernameVisible ? decryptedUsername : "●●●●●●●●"} className="w-full bg-transparent text-gray-900 dark:text-white focus:outline-none" /><button onClick={handleToggleUsername} className="p-1 text-gray-500 hover:text-gray-700 dark:hover:text-gray-300"><Icon name={isUsernameVisible ? 'visibility_off' : 'visibility'} className="text-xl"/></button><button onClick={() => handleCopy(credential.username, 'Usuario')} className="p-1 text-gray-500 hover:text-gray-700 dark:hover:text-gray-300"><Icon name="content_copy" className="text-xl"/></button></div></div><div><label className="text-xs font-medium text-gray-500 dark:text-gray-400">Contraseña</label><div className="flex items-center mt-1"><input type={isPasswordVisible ? 'text' : 'password'} readOnly value={isPasswordVisible ? decryptedPassword : "●●●●●●●●"} className="w-full bg-transparent text-gray-900 dark:text-white focus:outline-none" /><button onClick={handleTogglePassword} className="p-1 text-gray-500 hover:text-gray-700 dark:hover:text-gray-300"><Icon name={isPasswordVisible ? 'visibility_off' : 'visibility'} className="text-xl"/></button><button onClick={() => handleCopy(credential.password, 'Contraseña')} className="p-1 text-gray-500 hover:text-gray-700 dark:hover:text-gray-300"><Icon name="content_copy" className="text-xl"/></button></div></div>{credential.comment && (<div><label className="text-xs font-medium text-gray-500 dark:text-gray-400">Comentario</label><p className="mt-1 text-sm text-gray-800 dark:text-gray-200 whitespace-pre-wrap">{credential.comment}</p></div>)}</div><div className="mt-4 flex justify-end space-x-2"><button onClick={() => onEdit(credential)} className="flex items-center text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 p-2 rounded-md hover:bg-gray-100 dark:hover:bg-zinc-600"><Icon name="edit" className="text-base mr-1"/> Editar</button><button onClick={() => onDelete(credential.id)} className="flex items-center text-sm text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 p-2 rounded-md hover:bg-gray-100 dark:hover:bg-zinc-600"><Icon name="delete" className="text-base mr-1"/> Borrar</button></div></div>)}</div>); };
    const CredentialList = ({ credentials, onEdit, onDelete, masterKey }) => { if (credentials.length === 0) { return (<div className="text-center py-16"><Icon name="key_off" className="text-5xl text-gray-400 mx-auto" /><h3 className="mt-2 text-lg font-medium text-gray-900 dark:text-white">No se encontraron credenciales</h3><p className="mt-1 text-sm text-gray-500 dark:text-gray-400">Comience agregando una nueva credencial.</p><p className="mt-1 text-sm text-gray-500 dark:text-gray-400">Haga clic en el botón <Icon name="add" className="inline-block text-base" /> para comenzar.</p></div>); } return (<div className="space-y-3">{credentials.map(cred => (<CredentialItem key={cred.id} credential={cred} onEdit={onEdit} onDelete={onDelete} masterKey={masterKey} />))}</div>); };
    
    const FilterDropdown = ({ tags, onFilterChange, activeFilters }) => { const { useState, useRef, useEffect } = React; const [isOpen, setIsOpen] = useState(false); const [selectedTags, setSelectedTags] = useState(new Set(activeFilters)); const wrapperRef = useRef(null); const handleToggleTag = (tagName) => { setSelectedTags(prev => { const newSet = new Set(prev); if (newSet.has(tagName)) newSet.delete(tagName); else newSet.add(tagName); return newSet; }); }; const handleApply = () => { onFilterChange(Array.from(selectedTags)); setIsOpen(false); }; const handleClear = () => { setSelectedTags(new Set()); onFilterChange([]); setIsOpen(false); }; useEffect(() => { function handleClickOutside(event) { if (wrapperRef.current && !wrapperRef.current.contains(event.target)) setIsOpen(false); } document.addEventListener("mousedown", handleClickOutside); return () => document.removeEventListener("mousedown", handleClickOutside); }, [wrapperRef]); return ( <div className="relative inline-block text-left" ref={wrapperRef}> <button onClick={() => setIsOpen(!isOpen)} className="inline-flex justify-center w-full rounded-md border border-gray-300 dark:border-zinc-600 shadow-sm px-4 py-2 bg-white dark:bg-zinc-700 text-sm font-medium text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-zinc-600"> <Icon name="filter_list" className="mr-2 -ml-1"/> Filtros {activeFilters.length > 0 && `(${activeFilters.length})`} <Icon name="expand_more" className="ml-2 -mr-1"/> </button> {isOpen && ( <div className="origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white dark:bg-zinc-800 ring-1 ring-black ring-opacity-5 z-20"> <div className="p-2 text-gray-900 dark:text-gray-100 font-semibold">Filtrar por Etiqueta</div> <div className="py-1 max-h-60 overflow-y-auto"> {tags.map(tag => ( <label key={tag.id} className="flex items-center px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-zinc-700 cursor-pointer"> <input type="checkbox" checked={selectedTags.has(tag.name)} onChange={() => handleToggleTag(tag.name)} className="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500"/> <span className="ml-3">{tag.name}</span> </label> ))} </div> <div className="p-2 border-t border-gray-200 dark:border-zinc-700 flex justify-between"> <button onClick={handleClear} className="text-sm text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">Limpiar</button> <button onClick={handleApply} className="text-sm font-semibold text-blue-600 hover:text-blue-800 dark:text-blue-400">Aplicar</button> </div> </div> )} </div> ); };
    const SearchBar = ({ onSearch, onFilterChange, activeFilters, tags }) => ( <div className="mb-6 space-y-4"> <div className="relative"> <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3"><Icon name="search" className="text-gray-400" /></div> <input type="search" onChange={(e) => onSearch(e.target.value)} placeholder="Buscar por nombre o comentario..." className="block w-full rounded-lg border border-gray-300 dark:border-zinc-600 bg-gray-50 dark:bg-zinc-700 py-3 pl-10 pr-4 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500" /> </div> <div className="flex justify-center"> <FilterDropdown tags={tags} onFilterChange={onFilterChange} activeFilters={activeFilters} /> </div> </div> );
    
    // --- Main Interface Core ---
    const MainInterface = ({ db, masterKey, onSignOut, onSaveChanges, hasUnsavedChanges, setHasUnsavedChanges, user, saveStatus }) => {
      const { useState, useEffect, useCallback, useMemo } = React;
      const [credentials, setCredentials] = useState([]);
      const [tags, setTags] = useState([]);
      const [keychainName, setKeychainNameState] = useState('MiLlavero');
      const [isLoading, setIsLoading] = useState(true);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [isSettingsOpen, setIsSettingsOpen] = useState(false);
      const [editingCredential, setEditingCredential] = useState(null);
      const [searchTerm, setSearchTerm] = useState('');
      const [filterTags, setFilterTags] = useState([]);
      const addToast = useNotifier();

      const refreshData = useCallback(() => {
        setIsLoading(true);
        try {
          setCredentials(getCredentials(db));
          setTags(getTags(db));
          setKeychainNameState(getKeychainName(db));
        } catch (error) { addToast('Error al leer datos del llavero.', 'error'); onSignOut(); } 
        finally { setIsLoading(false); }
      }, [db, onSignOut, addToast]);

      useEffect(() => { refreshData(); }, [refreshData]);
      
      const handleAddOrUpdate = (credential) => { if (credential.id && credential.id > 0) updateCredential(db, credential); else addCredential(db, credential); setHasUnsavedChanges(true); refreshData(); setIsModalOpen(false); setEditingCredential(null); };
      const handleDelete = (id) => { if (window.confirm('¿Está seguro?')) { deleteCredential(db, id); setHasUnsavedChanges(true); refreshData(); }};
      const handleEdit = (credential) => { setEditingCredential(credential); setIsModalOpen(true); };
      const handleAddNew = () => { setEditingCredential(null); setIsModalOpen(true); };
      const handleSaveKeychainName = (newName) => { setKeychainName(db, newName); setKeychainNameState(newName); setHasUnsavedChanges(true); };
      const handleAddTag = (tagName) => { try { addTag(db, tagName); setHasUnsavedChanges(true); setTags(getTags(db)); } catch(e) { addToast("Error: " + e.message, "error"); } };
      const handleDeleteTag = (tagId) => { try { deleteTag(db, tagId); setHasUnsavedChanges(true); refreshData(); } catch(e) { addToast("Error: " + e.message, "error"); } };
      
      const filteredCredentials = useMemo(() => credentials.filter(c => (filterTags.length === 0 || filterTags.includes(c.tag)) && (searchTerm.length === 0 || c.name.toLowerCase().includes(searchTerm.toLowerCase()) || (c.comment && c.comment.toLowerCase().includes(searchTerm.toLowerCase())))).sort((a, b) => a.name.localeCompare(b.name)), [credentials, searchTerm, filterTags]);
      
      const SaveButton = () => {
        let content;
        switch (saveStatus) {
            case 'saving': content = <><Spinner className="border-gray-400" /> Guardando...</>; return <div className="flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-semibold bg-gray-200 dark:bg-zinc-700 text-gray-800 dark:text-gray-200"> {content} </div>;
            case 'saved': content = <><Icon name="cloud_done" className="text-lg mr-1 text-green-500" /> Guardado</>; return <div className="flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-semibold bg-gray-200 dark:bg-zinc-700 text-gray-800 dark:text-gray-200"> {content} </div>;
            case 'error': content = <><Icon name="error" className="text-lg mr-1 text-red-500" /> Error</>; return <button onClick={onSaveChanges} className="flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-semibold bg-red-100 dark:bg-red-900/50 text-red-700 dark:text-red-200 hover:bg-red-200 dark:hover:bg-red-900">{content}</button>;
            default: if (hasUnsavedChanges) { return <button onClick={onSaveChanges} className="flex items-center px-3 py-2 rounded-lg text-sm font-semibold transition-all bg-blue-600 text-white hover:bg-blue-700 animate-pulse"><Icon name="save" className="text-lg mr-1" />Guardar Cambios</button>; } return <div className="flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-semibold bg-gray-200 dark:bg-zinc-700 text-gray-800 dark:text-gray-200"><Icon name="cloud_done" className="text-lg mr-1 text-green-500" /> Guardado</div>;
        }
      };

      return (
        <div className="max-w-4xl mx-auto min-h-screen bg-white dark:bg-zinc-800 shadow-lg md:rounded-2xl flex flex-col">
          <div className="sticky top-16 z-20 flex flex-col md:flex-row md:items-center justify-between gap-4 p-4 border-b border-gray-200 dark:border-zinc-700 bg-gray-50/80 dark:bg-zinc-800/80 backdrop-blur-sm">
            <div className="font-semibold text-gray-700 dark:text-gray-200 truncate text-center md:text-left">{keychainName}</div>
            <div className="flex items-center justify-center md:justify-end flex-wrap gap-2">
                <SaveButton/>
                <button onClick={() => setIsSettingsOpen(true)} className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-zinc-700 text-gray-600 dark:text-gray-300" title="Configuración"><Icon name="settings" /></button>
                <button onClick={onSignOut} className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-zinc-700 text-gray-600 dark:text-gray-300" title="Salir y cerrar sesión"><Icon name="exit_to_app" /></button>
            </div>
          </div>
          <main className="flex-grow p-4 sm:p-6 pb-24 overflow-y-auto"><SearchBar onSearch={setSearchTerm} onFilterChange={setFilterTags} activeFilters={filterTags} tags={tags} />{isLoading ? <p>Cargando...</p> : <CredentialList credentials={filteredCredentials} onEdit={handleEdit} onDelete={handleDelete} masterKey={masterKey} />}</main>
          <div className="fixed bottom-16 right-4 sm:right-6 z-20"><button onClick={handleAddNew} className="bg-blue-600 hover:bg-blue-700 text-white rounded-full p-4 shadow-lg"><Icon name="add" className="text-2xl" /></button></div>
          <CredentialModal isOpen={isModalOpen} onClose={() => { setIsModalOpen(false); setEditingCredential(null); }} onSave={handleAddOrUpdate} credential={editingCredential} tags={tags} addToast={addToast} masterKey={masterKey} />
          <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} keychainName={keychainName} onSaveKeychainName={handleSaveKeychainName} tags={tags} onAddTag={handleAddTag} onDeleteTag={handleDeleteTag} addToast={addToast}/>
        </div>
      );
    };

    const LoadingScreen = ({ message }) => (<div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 dark:bg-zinc-900 text-gray-800 dark:text-gray-200"><Spinner className="border-blue-500" /><p className="mt-4 text-lg">{message}</p></div>);
    const AuthScreen = ({ onLogin, onSignUp, error, loading, configError }) => { const [isLoginView, setIsLoginView] = React.useState(true); const [email, setEmail] = React.useState(''); const [password, setPassword] = React.useState(''); const handleSubmit = (e) => { e.preventDefault(); if (isLoginView) onLogin(email, password); else onSignUp(email, password); }; if (configError) { return (<div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-zinc-900 p-4"><div className="w-full max-w-md bg-white dark:bg-zinc-800 rounded-2xl shadow-lg p-8 space-y-6 text-center"><div className="bg-red-100 dark:bg-red-900/50 border-l-4 border-red-500 text-red-700 dark:text-red-200 p-4 text-left"><p className="font-bold">Error de Configuración</p><p>{configError}</p></div></div></div>); } return (<div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-zinc-900 p-4"><div className="w-full max-w-md bg-white dark:bg-zinc-800 rounded-2xl shadow-lg p-8 space-y-6"><div className="text-center"><Icon name="key" className="text-5xl text-blue-500 mx-auto" /><h1 className="mt-4 text-3xl font-bold text-gray-900 dark:text-white">RDK APP</h1><p className="mt-2 text-sm text-gray-600 dark:text-gray-400">Su gestor de contraseñas seguro.</p></div><form className="space-y-6" onSubmit={handleSubmit}><input type="email" value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" required className="block w-full px-3 py-2 border border-gray-300 dark:border-zinc-600 rounded-md shadow-sm bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /><input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Contraseña" required className="block w-full px-3 py-2 border border-gray-300 dark:border-zinc-600 rounded-md shadow-sm bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" />{error && <p className="text-red-500 text-sm text-center">{error}</p>}<button type="submit" disabled={loading} className="w-full flex justify-center items-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50">{loading ? <Spinner /> : (isLoginView ? 'Iniciar Sesión' : 'Registrarse')}</button></form><p className="text-center text-sm text-gray-600 dark:text-gray-400">{isLoginView ? '¿No tiene cuenta?' : '¿Ya tiene una cuenta?'} <button onClick={() => setIsLoginView(!isLoginView)} className="font-medium text-blue-600 hover:text-blue-500 ml-1">{isLoginView ? 'Regístrese' : 'Inicie sesión'}</button></p></div></div>); };
    const CreateKeychainModal = ({ isOpen, onClose, onCreate, addToast }) => { const [name, setName] = React.useState(''); if (!isOpen) return null; const handleSubmit = (e) => { e.preventDefault(); if (name.trim()) onCreate(name.trim()); else addToast("El nombre no puede estar vacío.", "error"); }; return ( <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" onClick={onClose}><div className="bg-white dark:bg-zinc-800 rounded-lg shadow-xl w-full max-w-sm m-4" onClick={(e) => e.stopPropagation()}><form onSubmit={handleSubmit}><div className="p-6"><h2 className="text-xl font-bold text-gray-900 dark:text-white">Crear Nuevo Llavero</h2><p className="mt-2 text-sm text-gray-600 dark:text-gray-400">Asigne un nombre a su nuevo archivo.</p><input type="text" autoFocus value={name} onChange={e => setName(e.target.value)} placeholder="Ej: Llavero Principal" required className="mt-4 block w-full rounded-md border-gray-300 dark:border-zinc-600 shadow-sm bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /></div><div className="bg-gray-50 dark:bg-zinc-900/50 px-6 py-4 flex justify-end space-x-3"><button type="button" onClick={onClose} className="py-2 px-4 border border-gray-300 dark:border-zinc-600 rounded-md">Cancelar</button><button type="submit" className="py-2 px-4 border border-transparent rounded-md text-white bg-blue-600 hover:bg-blue-700">Crear</button></div></form></div></div>); };
    const KeychainSelector = ({ onSelectKeychain, onCreate, onSignOut, keychains, user }) => ( <div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-zinc-900 p-4"> <div className="w-full max-w-md bg-white dark:bg-zinc-800 rounded-2xl shadow-lg p-8"><div className="flex justify-between items-center mb-6"><div><h2 className="text-2xl font-bold text-gray-900 dark:text-white">Bienvenido,</h2><p className="text-gray-600 dark:text-gray-400 truncate max-w-[200px]">{user.email}</p></div><button onClick={onSignOut} className="text-sm text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 flex items-center gap-1"><Icon name="logout"/> Salir</button></div><button onClick={onCreate} className="w-full flex justify-center items-center py-3 px-4 mb-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"><Icon name="note_add" className="text-lg mr-2"/> Crear Nuevo Llavero</button><h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-6 mb-3 border-b border-gray-200 dark:border-zinc-600 pb-2">O abrir uno existente:</h3><div className="max-h-60 overflow-y-auto space-y-2">{keychains.length > 0 ? keychains.map(kc => (<button key={kc.id} onClick={() => onSelectKeychain(kc.name)} className="w-full text-left p-3 rounded-md hover:bg-gray-100 dark:hover:bg-zinc-700 flex items-center"><Icon name="database" className="text-blue-500 mr-3"/> <span className="text-gray-800 dark:text-gray-100">{kc.name}</span></button>)) : <p className="text-center text-gray-500 dark:text-gray-400 p-4">No hay llaveros existentes.</p>}</div></div></div>);
    const UnlockScreen = ({ onUnlock, keychainName, isCreating, onBack, addToast }) => { const [password, setPassword] = React.useState(''); const handleSubmit = (e) => { e.preventDefault(); if (password) onUnlock(password); else addToast("La contraseña no puede estar vacía.", "error"); }; const title = isCreating ? "Crear Contraseña Maestra" : `Desbloquear "${keychainName}"`; const prompt = isCreating ? "Establezca una contraseña maestra." : "Ingrese su contraseña maestra."; const buttonText = isCreating ? "Establecer y Guardar" : "Desbloquear"; return (<div className="flex items-center justify-center min-h-screen bg-gray-100 dark:bg-zinc-900 p-4"><div className="w-full max-w-md bg-white dark:bg-zinc-800 rounded-2xl shadow-lg p-8 space-y-6 text-center relative"><button onClick={onBack} className="absolute top-4 left-4 text-gray-500 hover:text-gray-800 dark:hover:text-gray-200"><Icon name="arrow_back"/></button><Icon name={isCreating ? "password" : "lock_open"} className="text-5xl text-blue-500 mx-auto" /><h2 className="text-2xl font-bold text-gray-900 dark:text-white">{title}</h2><p className="text-gray-600 dark:text-gray-400">{prompt}</p><form onSubmit={handleSubmit}><input type="password" autoFocus value={password} onChange={e => setPassword(e.target.value)} placeholder="Contraseña Maestra" required className="block w-full px-3 py-2 border border-gray-300 dark:border-zinc-600 rounded-md shadow-sm bg-gray-50 dark:bg-zinc-700 text-gray-900 dark:text-white" /><button type="submit" className="mt-4 w-full flex justify-center items-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700">{buttonText}</button></form></div></div>); };

    // --- MAIN APP COMPONENT ---
    const App = () => {
      const { useState, useCallback, useEffect, useRef } = React;
      // App State
      const [appStatus, setAppStatus] = useState('initializing');
      const [configError, setConfigError] = useState(null);
      const [authError, setAuthError] = useState('');
      const [loading, setLoading] = useState(false);
      const [isCreateModalOpen, setCreateModalOpen] = useState(false);
      // User & Keychain state
      const [user, setUser] = useState(null);
      const [keychains, setKeychains] = useState([]);
      const [db, setDb] = useState(null);
      const [dbFilename, setDbFilename] = useState('');
      const [masterKey, setMasterKey] = useState(null);
      const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
      const [saveStatus, setSaveStatus] = useState('saved');
      const addToast = useNotifier();

      const hasUnsavedChangesRef = useRef(hasUnsavedChanges);
      useEffect(() => { hasUnsavedChangesRef.current = hasUnsavedChanges; }, [hasUnsavedChanges]);
      
      const fetchKeychains = useCallback(async (userId) => {
        if (!userId) return;
        const { data, error } = await supabase.storage.from(BUCKET_NAME).list(userId, { limit: 100 });
        if (error) { console.error("Error fetching keychains:", error); setKeychains([]); }
        else { setKeychains(data.filter(f => f.name.endsWith('.db'))); }
      }, []);

      const handleSaveChanges = useCallback(async () => {
        if (!db || !user || !masterKey || saveStatus === 'saving') return;
        setSaveStatus('saving');
        try {
            const dbDataUint8 = exportDb(db);
            const encryptedDbBase64 = await encryptDBFile(dbDataUint8, masterKey);
            const salt = getSalt(db);
            const fileContent = new TextEncoder().encode(bufferToBase64(salt.buffer) + encryptedDbBase64);
            const path = `${user.id}/${dbFilename}`;
            const file = new File([fileContent], dbFilename, { type: 'application/octet-stream' });
            const { error } = await supabase.storage.from(BUCKET_NAME).upload(path, file, { upsert: true });
            if (error) throw error;
            setHasUnsavedChanges(false);
            setSaveStatus('saved');
            await fetchKeychains(user.id);
            addToast('¡Llavero guardado en la nube!', 'success');
        } catch (error) {
            console.error("Error saving to Supabase:", error);
            setSaveStatus('error');
            addToast("Error al guardar en la nube.", "error");
        }
      }, [db, dbFilename, user, masterKey, fetchKeychains, addToast, saveStatus]);

      useEffect(() => {
        const init = async () => {
          if (SUPABASE_URL.includes('YOUR_') || SUPABASE_ANON_KEY.includes('YOUR_')) { setConfigError("Las credenciales de Supabase no están configuradas."); setAppStatus('auth'); return; }
          if (!supabase) { setConfigError("No se pudo inicializar el cliente de Supabase."); setAppStatus('auth'); return; }
          window.SQL = await window.initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}` });
          const { data: { session } } = await supabase.auth.getSession();
          if (session) { setUser(session.user); await fetchKeychains(session.user.id); setAppStatus('select_keychain'); } 
          else { setAppStatus('auth'); }
        };
        init();
      }, [fetchKeychains]);

      const handleSignOut = useCallback(async (options = {}) => {
        if (hasUnsavedChangesRef.current && !window.confirm("Tiene cambios sin guardar que se perderán. ¿Seguro?")) return;
        await supabase.auth.signOut();
        setUser(null); setDb(null); setMasterKey(null); setHasUnsavedChanges(false); setAppStatus('auth');
        if (options.reason === 'inactivity') {
            addToast('Sesión cerrada por inactividad.', 'info');
        }
      }, [addToast]);
      
      const inactivityTimer = useRef(null);
      const resetInactivityTimer = useCallback(() => { clearTimeout(inactivityTimer.current); inactivityTimer.current = setTimeout(() => { handleSignOut({ reason: 'inactivity' }); }, SESSION_TIMEOUT_MS); }, [handleSignOut]);
      useEffect(() => { const events = ['mousemove', 'mousedown', 'keypress', 'scroll', 'touchstart']; if (appStatus === 'unlocked') { events.forEach(event => window.addEventListener(event, resetInactivityTimer)); resetInactivityTimer(); } return () => { events.forEach(event => window.removeEventListener(event, resetInactivityTimer)); clearTimeout(inactivityTimer.current); }; }, [appStatus, resetInactivityTimer]);

      useEffect(() => { if (hasUnsavedChanges) setSaveStatus('idle'); const debounceTimer = setTimeout(() => { if (hasUnsavedChanges) handleSaveChanges(); }, AUTOSAVE_DELAY); return () => clearTimeout(debounceTimer); }, [hasUnsavedChanges, handleSaveChanges]);
      useEffect(() => { const handleVisibilityChange = () => { if (document.visibilityState === 'hidden' && hasUnsavedChangesRef.current) handleSaveChanges(); }; document.addEventListener('visibilitychange', handleVisibilityChange); return () => document.removeEventListener('visibilitychange', handleVisibilityChange); }, [handleSaveChanges]);

      const handleSignUp = async (email, password) => { setLoading(true); setAuthError(''); const { error } = await supabase.auth.signUp({ email, password }); if (error) setAuthError(error.message); else addToast("¡Registro exitoso! Por favor, inicie sesión.", 'success'); setLoading(false); };
      const handleLogin = async (email, password) => { setLoading(true); setAuthError(''); const { data, error } = await supabase.auth.signInWithPassword({ email, password }); if (error) { setAuthError(error.message); } else if (data.user) { setUser(data.user); await fetchKeychains(data.user.id); setAppStatus('select_keychain'); } setLoading(false); };
      const handleCreateNewKeychain = async (name) => { setCreateModalOpen(false); const filename = name.endsWith('.db') ? name : `${name}.db`; if (keychains.some(kc => kc.name === filename)) { addToast("Ya existe un llavero con este nombre.", "error"); return; } const { database } = await initDb(null); setKeychainName(database, name); setDb(database); setDbFilename(filename); setAppStatus('unlock_keychain'); };
      const handleSelectKeychain = (filename) => { setDbFilename(filename); setAppStatus('unlock_keychain'); };
      const handleUnlockKeychain = useCallback(async (password) => {
          setLoading(true);
          try {
              let isNewFile = !keychains.some(kc => kc.name === dbFilename);
              if (!isNewFile) {
                  const path = `${user.id}/${dbFilename}`;
                  const { data: blob, error } = await supabase.storage.from(BUCKET_NAME).download(path);
                  if (error) throw error;
                  const fileContent = await blob.text();
                  const saltBase64 = fileContent.substring(0, 24);
                  const encryptedDbFileBase64 = fileContent.substring(24);
                  const salt = base64ToUint8Array(saltBase64);
                  const key = await deriveKey(password, salt);
                  const dbUint8Array = await decryptDBFile(encryptedDbFileBase64, key);
                  const { database } = await initDb(dbUint8Array);
                  setDb(database); setMasterKey(key); setAppStatus('unlocked'); setHasUnsavedChanges(false); setSaveStatus('saved');
              } else {
                  const salt = getSalt(db);
                  const key = await deriveKey(password, salt);
                  setMasterKey(key); setAppStatus('unlocked'); setHasUnsavedChanges(true); setSaveStatus('idle');
              }
          } catch (error) { console.error("Failed to unlock/set password:", error); addToast(error.message, "error"); setAppStatus('select_keychain'); } 
          finally { setLoading(false); }
      }, [db, dbFilename, user, keychains, addToast]);
      
      const goBackToSelector = () => { setDb(null); setDbFilename(''); setMasterKey(null); setAppStatus('select_keychain'); };

      const ActiveComponent = () => {
          if (appStatus === 'initializing') return <LoadingScreen message="Inicializando..." />;
          if (appStatus === 'auth') return <AuthScreen onLogin={handleLogin} onSignUp={handleSignUp} error={authError} loading={loading} configError={configError} />;
          if (appStatus === 'select_keychain') return (<> <KeychainSelector onSelectKeychain={handleSelectKeychain} onCreate={() => setCreateModalOpen(true)} onSignOut={handleSignOut} keychains={keychains} user={user} /> <CreateKeychainModal isOpen={isCreateModalOpen} onClose={() => setCreateModalOpen(false)} onCreate={handleCreateNewKeychain} addToast={addToast} /> </>);
          if (appStatus === 'unlock_keychain') return <UnlockScreen onUnlock={handleUnlockKeychain} keychainName={dbFilename} isCreating={!keychains.some(k => k.name === dbFilename)} onBack={goBackToSelector} addToast={addToast} />;
          if (appStatus === 'unlocked' && db && masterKey) return <MainInterface db={db} masterKey={masterKey} onSignOut={handleSignOut} onSaveChanges={handleSaveChanges} hasUnsavedChanges={hasUnsavedChanges} setHasUnsavedChanges={setHasUnsavedChanges} user={user} saveStatus={saveStatus} />;
          return <LoadingScreen message="Cargando..." />;
      }
      
      const isMainView = appStatus === 'unlocked' && db && masterKey;

      return (
        <>
            <GlobalHeader />
            <main className={isMainView ? 'pt-16 pb-10' : ''}>
                <ActiveComponent />
            </main>
            <GlobalFooter />
        </>
      );
    };
    
    // --- RENDER APP ---
    const rootElement = document.getElementById('root');
    const root = ReactDOM.createRoot(rootElement);
    root.render(
      <NotifierProvider>
        <App />
      </NotifierProvider>
    );

  </script>
</body>
</html>

